# -*- coding: utf-8 -*-
"""08-ipc-analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/161UeyWAS2fzJAIckjUeIzVjg-WFH7UsD
"""

from datetime import date

years = list(reversed(range(2018, date.today().year+1)))
years

#pip install git+https://Kenphilip:Josephineken123#@github.com/username/repo_name.git

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# # https://docs.api.ipcinfo.org/#/
# # https://observablehq.com/@ipc/ipc-api-extended-documentation
# 
# from typing import Optional, Any
# import requests
# import json
# from mukau.settings import Settings
# import pandas as pd
# from datetime import date
# 
# ipc_phase_codes = {
#     0: {'name': 'Not analyzed', 'color': '#fff'},
#     1: {'name': 'Minimal / phase 1', 'color': '#cef9ce'},
#     2: {'name': 'Stressed / phase 2', 'color': '#f9e43c'},
#     3: {'name': 'Crisis / phase 3', 'color': '#e4781f'},
#     4: {'name': 'Emergency / phase 4', 'color': '#c60813'},
#     5: {'name': 'Catastrophe / phase 5',  'color': '#640000'},
#     6: {'name': 'Famine likely / phase 5', 'color': '#640000'},
#     9: {'name': 'Insufficient evidence', 'color': ''},
# }
# 
# all_phases = [value['name'] for value in ipc_phase_codes.values()]
# 
# 
# settings = Settings()
# 
# iso_to_ipc_code = {
#     'KEN': "KE",
#     'TZA': "TZ",
#     'ETH': "ET",
#     'UGA': "UG",
#     'SSD': "SS",
#     'SDN': "SD",
#     'DJI': "DJ",
#     'SOM': "SO",
#     'BDI': "BI",
#     'RWA': "RW",
#     'ERI': 'ER'
# }
# 
# iso_to_name = {
#     'KEN': "Kenya",
#     'TZA': "Tanzania",
#     'ETH': "Ethiopia",
#     'UGA': "Uganda",
#     'SSD': "South Sudan",
#     'SDN': "Sudan",
#     'DJI': "Djibouti",
#     'SOM': "Somalia",
#     'BDI': "Burindi",
#     'RWA': "Rwanda",
#     'ERI': 'Eritrea'
# }
# 
# def make_get_request(endpoint: str, base_url: Optional[str] = 'https://api.ipcinfo.org', params: Optional[Any] = {}):
#     params.update({'key': settings.ipc_key, 'format': 'json'})
#     r = requests.get(f'{base_url}/{endpoint}', params=params)
#     if r.status_code != 200:
#         return {'valid': False, 'error': r.text, 'code': r.status_code}
#     return {'valid': True, 'data': r.json()}
# 
# def make_state_analysis_df(phases: list[Any], iso3: str, from_to: str, title: str):
#     return pd.DataFrame(data=phases).assign(
#         color=lambda x: x['phase'].apply(lambda phase: ipc_phase_codes[phase]['color']),
#         phase=lambda x: x['phase'].apply(lambda phase: ipc_phase_codes[phase]['name']),
#         label=f'{iso_to_name[iso3]} - {from_to}',
#         title=title
#     )
# 
# igad = []
# for iso3, iso2 in iso_to_ipc_code.items():
#     for year in years:
#         analysis_found = False
#         print(f"Fetching analysis for {iso_to_name[iso3]}, year {year}")
#         analysis = make_get_request(endpoint='country', params={'country': iso2, 'type':'A', 'year':year})
#         if analysis['valid']:
#             analysis_found = True
#             igad.append(make_state_analysis_df(
#                 phases=analysis['data'][0]['phases'],
#                 iso3=iso3,
#                 from_to=f"{analysis['data'][0]['from']} to {analysis['data'][0]['to']}",
#                 title=analysis['data'][0]['title']
#             ))
#             print(analysis['data'][0]['title'], iso_to_name[iso3])
#         if analysis_found:
#             break
# data = pd.concat(igad, ignore_index=True)
# data.head()

def fill_missing_df_values(df: pd.DataFrame, phase_col: str, admin_col: str):
    phases, admins = df[phase_col].unique().tolist(), df[admin_col].unique().tolist()
    fillers = [[phase, admin, 0] for phase in phases for admin in admins]
    filler_df = pd.DataFrame(data=fillers, columns=[phase_col, admin_col, 'zero'])
    return df.merge(filler_df, on=[phase_col, admin_col], how='right').fillna(0).drop('zero', axis=1)

ordered_phases = [phase for phase in all_phases if phase in data['phase'].unique().tolist()]
valid_data = data.query('percentage > 0 and population > 0').copy()
valid_data['phase'] = pd.Categorical(valid_data.phase, categories=ordered_phases, ordered=True)
sorted_df = valid_data.sort_values(by=['phase','population'], ascending=False)
ordered_labels = sorted_df.label.unique().tolist()
sorted_df.head()

filled_df = fill_missing_df_values(df=data, phase_col='phase', admin_col='label')
filled_df = filled_df.assign(
    phase = lambda x: pd.Categorical(x.phase, categories=ordered_phases, ordered=True),
    label = lambda x: pd.Categorical(x.label, categories=ordered_labels, ordered=True),
)
filled_df.head()

from pyecharts.globals import CurrentConfig, NotebookType

CurrentConfig.NOTEBOOK_TYPE = NotebookType.JUPYTER_LAB

from pyecharts import options as opts
from pyecharts.charts import Bar
from pyecharts.commons.utils import JsCode


bar = Bar({'theme':'black'}).add_xaxis(sorted_df['label'].unique().tolist())

for phase in reversed(ordered_phases):
    subset = filled_df.query('phase == @phase').copy()
    color = subset['color'].iloc[0]
    values = subset.drop(columns='color').sort_values(by='label').rename(columns={'population':'value'}).to_dict(orient='records')
    bar.add_yaxis(phase, values, stack="stack1", itemstyle_opts=opts.ItemStyleOpts(color=color), category_gap="40%")

bar.load_javascript()

(
    bar
    .set_series_opts(
        label_opts=opts.LabelOpts(is_show=False),
        tooltip_opts=opts.TooltipOpts(
            trigger="item", formatter=JsCode(
                """
                function(x){
                    return `${x.data.title}</br>${x.data.label}</br>` +
                        `Phase: ${x.data.phase}</br>Population: ${x.data.value}</br>Percentage: ${x.data.percentage}%`
                }
                """
            )
        )
    )
    .render_notebook()
)

totals = data.groupby(by='label').agg({'population': 'sum'}).reset_index().sort_values(by='population', ascending=False)
ordered_labels = totals.label.unique().tolist()

filled_df = fill_missing_df_values(df=data, phase_col='phase', admin_col='label')
filled_df = filled_df.assign(
    phase = lambda x: pd.Categorical(x.phase, categories=ordered_phases, ordered=True),
    label = lambda x: pd.Categorical(x.label, categories=ordered_labels, ordered=True),
)

bar = Bar({'theme':'black'}).add_xaxis(ordered_labels)

for phase in reversed(ordered_phases):
    subset = filled_df.query('phase == @phase').copy()
    color = subset['color'].iloc[0]
    values = subset.drop(columns='color').sort_values(by='label').rename(columns={'population':'value'}).to_dict(orient='records')
    bar.add_yaxis(phase, values, stack="stack1", itemstyle_opts=opts.ItemStyleOpts(color=color), category_gap="40%")

(
    bar
    .set_series_opts(
        label_opts=opts.LabelOpts(is_show=False),
        tooltip_opts=opts.TooltipOpts(
            trigger="item", formatter=JsCode(
                """
                function(x){
                    return `${x.data.title}</br>${x.data.label}</br>` +
                        `Phase: ${x.data.phase}</br>Population: ${x.data.value}</br>Percentage: ${x.data.percentage}%`
                }
                """
            )
        )
    )
    .render_notebook()
)

bar = (
    Bar({'theme':'black'})
    .add_xaxis(ordered_labels)
    .set_global_opts(
        title_opts=opts.TitleOpts(title="Latest Acutue Food Insecurity - ICPAC Region"),
        toolbox_opts=opts.ToolboxOpts(orient = 'vertical'),
        legend_opts=opts.LegendOpts(pos_left="450px",orient = 'vertical'),
        yaxis_opts=opts.AxisOpts(
            name="Population Affected",
            name_rotate=90,
            name_location='center',
            type_='value',
            name_gap=48,
            name_textstyle_opts=opts.TextStyleOpts(font_style='bold', font_size=18),
            axislabel_opts=opts.LabelOpts(
                font_size=10,
                rotate=35,
                margin=2,
            )
        ),
        xaxis_opts=opts.AxisOpts(
            type_='category',
            name='country/state, analysis date',
            name_location='center',
            name_gap=55,
            name_textstyle_opts=opts.TextStyleOpts(font_style='bold', font_size=18),
            axislabel_opts=opts.LabelOpts(
                font_size=10,
                rotate=22,
                margin=2,
            )
        )
    )
)


for phase in reversed(ordered_phases):
    subset = filled_df.query('phase == @phase').copy()
    color = subset['color'].iloc[0]
    values = subset.drop(columns='color').sort_values(by='label').rename(columns={'population':'value'}).to_dict(orient='records')
    bar.add_yaxis(phase, values, stack="stack1", itemstyle_opts=opts.ItemStyleOpts(color=color), category_gap="30%")

bar = bar.set_series_opts(
    label_opts=opts.LabelOpts(is_show=False),
    tooltip_opts=opts.TooltipOpts(
        trigger="item", formatter=JsCode(
            """
            function(x){
                return `
                ${x.data.label}</br>
                ${x.data.title}</br>
                Phase: ${x.data.phase}</br>
                Population: ${x.data.value}</br>
                Percentage: ${x.data.percentage} </br>`;
            }
            """
        )
    )
) #.reversal_axis()

bar.render_notebook()

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# def make_areas_dataframe(areas: Any):
#     if areas['valid']:
#         data = []
#         for area in areas['data']:
#             data.append(pd.DataFrame(data=area['phases']).assign(
#                 color=lambda x: x['phase'].apply(lambda phase: ipc_phase_codes[phase]['color']),
#                 phase=lambda x: x['phase'].apply(lambda phase: ipc_phase_codes[phase]['name']),
#                 est_population=area['estimated_population'],
#                 title=f"{area['title']} - {area['from']} to {area['to']}",
#                 overall_phase=ipc_phase_codes[area['overall_phase']]['name']
#             ))
#         return pd.concat(data, ignore_index=True).query('population > 0 and percent > 0')
#     return pd.DataFrame()
# 
# areas = make_get_request(endpoint='areas', params={'country': iso_to_ipc_code['KEN'], 'year': 2023})
# df = make_areas_dataframe(areas)
# df.head()

def get_phase_color(phase: str):
    phase_map = [val for val in ipc_phase_codes.values() if val['name'] == phase][0]
    return phase_map['color']


def get_data_for_state(iso2: str):
    for year in years:
        areas = make_get_request(endpoint='areas', params={'country': iso2, 'year': year})
        if areas['valid']:
            return make_areas_dataframe(areas)
    return None

def make_plot_for_state(iso3: str):
    data = get_data_for_state(iso2=iso_to_ipc_code[iso3])
    if data is not None:
        totals = data.groupby(by='title').agg({'population': 'sum'}).reset_index().sort_values(by='population', ascending=False)
        ordered_titles = totals.title.unique().tolist()

        filled_df = fill_missing_df_values(df=data, phase_col='phase', admin_col='title')
        filled_df = filled_df.assign(
            color=lambda x: x['phase'].apply(lambda phase: get_phase_color(phase)),
            phase = lambda x: pd.Categorical(x.phase, categories=ordered_phases, ordered=True),
            title = lambda x: pd.Categorical(x.title, categories=ordered_titles, ordered=True),
        )
        bar = (
            Bar({'theme':'black'})
            .add_xaxis(ordered_titles)
            .set_global_opts(
                title_opts=opts.TitleOpts(title=f"Latest Acutue Food Insecurity - {iso_to_name[iso3]}"),
                toolbox_opts=opts.ToolboxOpts(orient = 'vertical'),
                legend_opts=opts.LegendOpts(pos_left="450px",orient = 'vertical'),
                yaxis_opts=opts.AxisOpts(
                    name="Population Affected",
                    name_rotate=90,
                    name_location='center',
                    type_='value',
                    name_gap=48,
                    name_textstyle_opts=opts.TextStyleOpts(font_style='bold', font_size=18),
                    axislabel_opts=opts.LabelOpts(
                        font_size=10,
                        rotate=35,
                        margin=2,
                    )
                ),
                xaxis_opts=opts.AxisOpts(
                    type_='category',
                    name='sub-admin, analysis date',
                    name_location='center',
                    name_gap=55,
                    name_textstyle_opts=opts.TextStyleOpts(font_style='bold', font_size=18),
                    axislabel_opts=opts.LabelOpts(
                        font_size=10,
                        rotate=22,
                        margin=2,
                    )
                )
            )
        )


        for phase in reversed(ordered_phases):
            subset = filled_df.query('phase == @phase').copy()
            if len(subset):
                color = subset['color'].iloc[0]
                values = subset.drop(columns='color').sort_values(by='title').rename(columns={'population':'value'}).to_dict(orient='records')
                bar.add_yaxis(phase, values, stack="stack1", itemstyle_opts=opts.ItemStyleOpts(color=color), category_gap="30%")

        bar = bar.set_series_opts(
            label_opts=opts.LabelOpts(is_show=False),
            tooltip_opts=opts.TooltipOpts(
                trigger="item", formatter=JsCode(
                    """
                    function(x){
                        return `
                        ${x.data.title}</br>
                        Phase: ${x.data.phase}</br>
                        Overall Phase: ${x.data.overall_phase}</br>
                        Est Total Population: ${x.data.est_population}</br>
                        Population Affected: ${x.data.value}</br>
                        Percentage: ${x.data.percent} </br>`;
                    }
                    """
                )
            )
        )

        return bar
    return None

bar = make_plot_for_state('KEN')
bar.render_notebook()

bar = make_plot_for_state('UGA')
bar.render_notebook()

phases = [
    [ipc_phase_codes[item['phase']]['name'], item['population']]
     for item in areas['data'][0]['phases'] if item['population'] > 0
]
phases

colors = [ipc_phase_codes[item['phase']]['color'] for item in areas['data'][0]['phases']]
colors

from pyecharts.charts import Pie

pie = (
    Pie()
    .add(
        series_name = areas['data'][0]['title'],
        data_pair = phases,
        radius = ["35%", "80%"],
        label_opts = opts.LabelOpts(is_show=False, position="center")
    )
    .set_colors(colors)
    .set_global_opts(
        title_opts=opts.TitleOpts(title="IPC Acute Food Insecurity - Kajiando")
    )
    .set_series_opts(
        label_opts=opts.LabelOpts(formatter="{b}, {c} {d}%")
   )
)

pie.render_notebook()

