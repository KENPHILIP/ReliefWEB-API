# -*- coding: utf-8 -*-
"""GlideNumber_Extract.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zuou8-lguJ1speptrGDXnzgVwp8FO8oC
"""

import pandas as pd
import re
from datetime import datetime
import numpy as np

df3 = pd.read_csv('/content/ICPAC cleaned data - Sheet2(GlideNumber).csv')

# List of ICPAC countries
icpac_countries = ['Burundi', 'Djibouti', 'Eritrea', 'Ethiopia', 'Kenya', 'Rwanda', 'Somalia', 'South Sudan', 'Sudan', 'Uganda']

# Filter the DataFrame for ICPAC countries
filtered_df3 = df3[df3['Countries'].isin(icpac_countries)]

# Print the first few rows of the filtered DataFrame
print(filtered_df3.head())

# Save the filtered DataFrame to a CSV file
filtered_df3.to_csv('/content/icpac_countries(GlideNumber).csv', index=False)

# generate the Comments the whole column printed everything captured

for index, row in df.iterrows():
  print(row['Comments'])

# Load data from your CSV file
file_path = '/content/icpac_countries(GlideNumber).csv'
df = pd.read_csv(file_path)

# Ensure the 'Comments' column exists
if 'Comments' not in df.columns:
    raise ValueError("The 'Comments' column is missing from the CSV file.")

# Define lists of known locations, countries, and disaster types
known_locations = [
    'Kosti', 'Jodha', 'Uige', 'Angola', 'South Sudan', 'Republic of Congo', 'Sudan',
    'Nairobi', 'Juba', 'Kinshasa', 'Addis Ababa', 'Mbale Municipal', 'Nebbi Municipal', 'Nebbi Hoima & Buliisa',
    'Namaaga', 'Bunakasala', 'Bunagana', 'Kisoro', 'Kigwera Sub County', 'Butiaba Sub County', 'Butiaba Town Council',
    'Tonya Parish', 'Buseruka Sub County', 'Parambo', 'Kaiso Village', 'Kiryandongo (Mutunda sub-county)', 'Amuru',
    'Oyam', 'Koboko', 'Musanze Northern Province', 'Nyabihu', 'Rubavu districts',
    'Gode', 'Korahe'
]
known_countries = [
    'South Sudan', 'Sudan', 'Kenya', 'Ethiopia', 'Uganda', 'Rwanda', 'Burundi', 'Tanzania', 'Djibouti',
    'Eritrea', 'Somalia'
]
disaster_types = [
    'flood', 'epidemic', 'rain', 'polio', 'cholera', 'earthquake', 'hurricane',
    'cyclone', 'drought', 'tsunami', 'landslide', 'volcanic eruption', 'fire',
    'storm', 'heatwave', 'coldwave', 'tornado', 'avalanche', 'pest infestation',
    'meningitis', 'flash floods', 'flooding', 'Marburg haemorrhagic fever',
    'Ebola haemorrhagic fever', 'upsurge of refugees'
]

# Function to extract date, location, disaster type, and impact figures
def extract_info(text):
    if not isinstance(text, str):
        return {
            'day': np.nan,
            'month': np.nan,
            'year': np.nan,
            'locations': np.nan,
            'country': np.nan,
            'disaster_type': np.nan,
            'missing': np.nan,
            'deaths': np.nan,
            'killed': np.nan,
            'displaced': np.nan,
            'households': np.nan,
            'damaged_houses': np.nan,
            'schools': np.nan,
            'health_facilities': np.nan
        }

    # Enhanced regular expression for extracting dates
    date_patterns = [
        r'\b(\d{1,2}(?:st|nd|rd|th)? [A-Za-z]+ \d{4})\b',  # e.g., 24th February 2012
        r'\b(\d{1,2} [A-Za-z]+ \d{4})\b',  # e.g., 24 February 2012
        r'\b(\d{1,2} [A-Za-z]+ \d{2})\b',  # e.g., 24 Feb 12
        r'\b([A-Za-z]+ \d{4})\b',           # e.g., February 2012
        r'\b(\d{1,2} [A-Za-z]+)\b',         # e.g., 19 Oct
        r'\b(?:end of [A-Za-z]+ \d{4})\b',   # e.g., end of February 2012
        r'\b(\d{1,2}-\d{1,2} [A-Za-z]+ \d{4})\b' # e.g., 27-28 Sep 2012
    ]

    date = None
    for pattern in date_patterns:
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            date = match.group(0)
            break

    # Initialize date components
    day = month = year = np.nan

    if date:
        try:
            if 'end of' in date:
                # Extract month and year from "end of Month Year"
                month_year = date.replace('end of ', '')
                date_obj = datetime.strptime(f"01 {month_year}", "%d %B %Y")
                day = np.nan
                month = date_obj.strftime("%B")
                year = date_obj.year
            else:
                # Handle date ranges like "27-28 Sep 2012"
                if '-' in date:
                    date_range = date.split('-')
                    date_obj = datetime.strptime(date_range[1].strip(), "%d %b %Y")
                else:
                    # Extract day, month, and year from other formats
                    if len(date.split()) == 3:
                        date_obj = datetime.strptime(date, "%d %B %Y")
                    elif len(date.split()) == 2:
                        if len(date.split()[1]) == 2:  # Handle "Jan 12" format
                            date_obj = datetime.strptime(f"01 {date}", "%d %b %y")
                        else:  # Handle "Jan 2012" format
                            date_obj = datetime.strptime(f"01 {date}", "%d %B %Y")
                    else:
                        date_obj = datetime.strptime(date, "%d %b %Y")
                day = date_obj.day
                month = date_obj.strftime("%B")
                year = date_obj.year
        except ValueError:
            day = month = year = np.nan

    # Extract locations
    location_patterns = [
        r'\b(?:' + '|'.join(known_locations) + r')\b',
        r'\b(?:state|region|zone|county|province|district|area|town|city|sub-county|subdistrict)\s+([A-Za-z\s]+)\b',
        r'\b(?:' + '|'.join(known_locations) + r'|state|region|zone|county|province|district|area|town|city|sub-county|subdistrict)\b'
    ]

    locations = []
    for pattern in location_patterns:
        matches = re.findall(pattern, text, re.IGNORECASE)
        if matches:
            locations.extend(matches)

    # Additional handling for complex location sentences
    complex_locations = [
        'Nebbi Hoima', 'Kigwera Sub County', 'Butiaba Sub County', 'Butiaba Town Council', 'Tonya Parish',
        'Buseruka Sub County', 'Parambo', 'Kiryandongo (Mutunda sub-county)', 'Musanze Northern Province',
        'Nyabihu', 'Rubavu districts', 'Gode', 'Korahe'
    ]

    # Find and add complex locations
    for loc in complex_locations:
        if loc.lower() in text.lower():
            locations.append(loc)

    locations = ', '.join(set(locations)) if locations else np.nan

    # Extract country
    country_pattern = re.compile(r'\b(?:' + '|'.join(known_countries) + r')\b', re.IGNORECASE)
    country = country_pattern.search(text)
    country = country.group(0) if country else np.nan

    # Extract disaster type
    disaster_pattern = re.compile(r'\b(?:' + '|'.join(disaster_types) + r')\b', re.IGNORECASE)
    disaster_type = disaster_pattern.search(text)
    disaster_type = disaster_type.group(0) if disaster_type else np.nan

    # Extract impact figures
    impact_patterns = {
        'missing': r'\b(?:missing|missing persons|missing people)\b.*?(\d+,\d+|\d+)',
        'deaths': r'\b(?:deaths|killed)\b.*?(\d+,\d+|\d+)',
        'killed': r'\b(?:killed)\b.*?(\d+,\d+|\d+)',
        'displaced': r'\b(?:displaced)\b.*?(\d+,\d+|\d+)',
        'households': r'\b(\d+,\d+|\d+)\s*households?\b',
        'damaged_houses': r'\b(\d+,\d+|\d+)\s*damaged\s*houses?\b',
        'schools': r'\b(\d+,\d+|\d+)\s*schools?\b',
        'health_facilities': r'\b(\d+,\d+|\d+)\s*health\s*facilities?\b'
    }

    impacts = {}
    for key, pattern in impact_patterns.items():
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            # Remove any commas from the number
            impacts[key] = match.group(1).replace(',', '')
        else:
            impacts[key] = np.nan

    return {
        'day': day,
        'month': month,
        'year': year,
        'locations': locations,
        'country': country,
        'disaster_type': disaster_type,
        'missing': impacts['missing'],
        'deaths': impacts['deaths'],
        'killed': impacts['killed'],
        'displaced': impacts['displaced'],
        'households': impacts['households'],
        'damaged_houses': impacts['damaged_houses'],
        'schools': impacts['schools'],
        'health_facilities': impacts['health_facilities']
    }

# Apply the function to the 'Comments' column
df_extracted = df['Comments'].apply(extract_info).apply(pd.Series)

# Combine extracted data with original DataFrame
df_combined = pd.concat([df, df_extracted], axis=1)

# Save the updated DataFrame to a new CSV file
output_file_path = '/content/extracted_icpac_data.csv'
df_combined.to_csv(output_file_path, index=False)

print(f"Data extraction complete. Updated file saved to: {output_file_path}")

